locals {
  # ... (restante das locals)

  # Adicione a referência ao ARN do Service Discovery Namespace
  service_discovery_namespace_arn = aws_service_discovery_http_namespace.this.arn


  ecs_service_configs = { for service_name, service_attrs in local.ecs_services_input : service_name => {
    # ... (outros parâmetros do serviço)

    # === BLOCO CORRIGIDO PARA MULTIPLOS CONTAINERS: service_connect_configuration ===
    service_connect_configuration = service_attrs.enable_service_connect ? {
      namespace = local.service_discovery_namespace_arn
      service = {
        # Itera sobre CADA container definido para este serviço
        for container_name, container_def in service_attrs.container_definitions : container_name => {
          client_alias = [
            {
              port     = container_def.container_port # A porta do container atual
              # O alias pode ser o nome do container, ou um alias mais específico se definido
              dns_name = lookup(container_def, "service_connect_client_alias", container_name)
            }
          ]
          port_name     = container_def.container_port # A porta do container atual
          discovery_name = container_name # O nome do container como nome de descoberta
        }
      }
    } : null # Se enable_service_connect for false, o bloco será nulo
    # ===============================================

    # ... (restante dos parâmetros do serviço)

  }}
  # ... (restante das locals)
}

# variables.tf
variable "ecs_services" {
  description = "A map of ECS service configurations."
  type = map(object({
    cpu = number
    memory = number
    container_definitions = map(object({
      image = string
      container_port = optional(number)
      essential = optional(bool, true)
      cpu = optional(number)
      memory = optional(number)
      environment = optional(map(string), {})
      firelens_configuration = optional(map(string), {})
      log_configuration = optional(any, null)
      # NOVO CAMPO AQUI: service_connect_client_alias para cada container
      service_connect_client_alias = optional(string)
    }))
    health_check_path = string
    health_check_port = string
    desired_count = number
    min_healthy_percent = number
    max_percent = number
    alb_listener_port = number
    alb_protocol = string
    alb_host_header = string
    additional_task_role_policy_arns = optional(list(string), [])
    enable_service_connect = optional(bool, false) # Este já estava lá no nível do serviço
  }))
}

{
  "ecs_services": {
    "my-multi-container-app": {
      "cpu": 1024,
      "memory": 2048,
      "container_definitions": {
        "web-app": {
          "image": "my-web-app:latest",
          "container_port": 80,
          "service_connect_client_alias": "webapp-alias" # Alias para este container
        },
        "sidecar-service": {
          "image": "my-sidecar:latest",
          "container_port": 5000,
          "essential": false,
          "service_connect_client_alias": "sidecar-alias" # Alias para este container
        }
      },
      // ... outros campos
      "enable_service_connect": true
    }
  }
}

