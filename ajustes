
locals {
  # ... (restante das locals)

  # Adicione a referência ao ARN do Service Discovery Namespace
  service_discovery_namespace_arn = aws_service_discovery_http_namespace.this.arn
  # ... (restante das locals)


  ecs_service_configs = { for service_name, service_attrs in local.ecs_services_input : service_name => {
    # ... (outros parâmetros do serviço)

    # Obter o nome do primeiro container para facilitar a referência
    first_container_name = keys(service_attrs.container_definitions)[0]
    # Obter a definição do primeiro container
    first_container_def  = service_attrs.container_definitions[local.first_container_name]

    # === BLOCO CORRIGIDO: service_connect_configuration ===
    service_connect_configuration = service_attrs.enable_service_connect ? {
      namespace = local.service_discovery_namespace_arn
      service = {
        # A chave DEVE ser o nome do container
        "${local.first_container_name}" = {
          client_alias = [
            {
              port     = local.first_container_def.container_port # Referencia a porta do container
              dns_name = lookup(service_attrs, "service_connect_client_alias", local.first_container_name)
            }
          ]
          port_name     = local.first_container_def.container_port # Referencia a porta do container
          discovery_name = local.first_container_name # Nome do container como nome de descoberta
        }
      }
    } : null # Se enable_service_connect for false, o bloco será nulo
    # ===============================================

    # ... (restante dos parâmetros do serviço)

  }}
  # ... (restante das locals)
}

locals {
  # ... (restante das locals)

  # Adicione a referência ao ARN do Service Discovery Namespace
  # Se você cria o namespace com um recurso direto (aws_service_discovery_http_namespace.this),
  # você pode referenciá-lo assim:
  service_discovery_namespace_arn = aws_service_discovery_http_namespace.this.arn
  # Se o módulo ECS cria e expõe o namespace, a referência seria diferente,
  # por exemplo: module.ecs_main.service_discovery_namespace_arn (verifique a output do módulo)


  ecs_service_configs = { for service_name, service_attrs in local.ecs_services_input : service_name => {
    # ... (outros parâmetros do serviço)

    # === NOVO BLOCO: service_connect_configuration ===
    # A foto mostra que o `namespace` é `aws_service_discovery_http_namespace.this.arn`.
    # Vamos assumir que você tem esse recurso em main.tf, ou o obtém de outro lugar.
    service_connect_configuration = service_attrs.enable_service_connect ? {
      namespace = local.service_discovery_namespace_arn # ou module.ecs_main.service_discovery_namespace_arn se o módulo o cria
      service = {
        # O Terraform espera um mapa onde a chave é o nome do container
        # e o valor é a configuração do serviço.
        # Estamos pegando o nome do PRIMEIRO container definido para o serviço.
        "${keys(service_attrs.container_definitions)[0]}" = { # Key deve ser o nome do container
          client_alias = [
            {
              port     = service_attrs.container_definitions[keys(service_attrs.container_definitions)[0]].container_port # A porta do container
              dns_name = lookup(service_attrs, "service_connect_client_alias", keys(service_attrs.container_definitions)[0]) # Usa alias custom ou nome do container
            }
          ]
          port_name     = service_attrs.container_definitions[keys(service_attrs.container_definitions)[0]].container_port # A porta do container
          discovery_name = keys(service_attrs.container_definitions)[0] # Nome do container como nome de descoberta
        }
      }
    } : null # Se enable_service_connect for false, o bloco será nulo
    # ===============================================

  }}
  # ... (restante das locals)
}

# variables.tf

variable "ecs_services" {
  description = "A map of ECS service configurations."
  type = map(object({
    # ... (outros campos existentes)

    # NOVO CAMPO PARA SERVICE CONNECT
    enable_service_connect = optional(bool, false)
    # Se quiser personalizar o alias, pode adicionar:
    # service_connect_client_alias = optional(string)
    # ... (restante da variável)
  }))
}

# Também pode precisar de uma variável para o nome do namespace se não for fixo
variable "service_discovery_namespace_name" {
  description = "The name of the AWS Service Discovery HTTP Namespace for Service Connect."
  type        = string
  default     = "app-namespace" # Ou um nome que você já tenha
}

# main.tf (Exemplo, se você não tem isso)
resource "aws_service_discovery_http_namespace" "this" {
  name        = "${local.project_name}-app-namespace"
  description = "HTTP namespace for application services"
}

# Em locals.tf, você o referenciaria como:
# local.service_discovery_namespace_arn = aws_service_discovery_http_namespace.this.arn

# main.tf

provider "aws" {
  region = local.aws_region
}

# --- Adicione a criação do Service Discovery HTTP Namespace se ainda não existe ---
resource "aws_service_discovery_http_namespace" "this" {
  name        = "${local.project_name}-${local.service_discovery_namespace_name}"
  description = "HTTP namespace for ECS Service Connect"
  tags = {
    Environment = "Development"
    Project     = local.project_name
  }
}
# ---------------------------------------------------------------------------------

# Cria o cluster ECS e todos os serviços Fargate dentro dele
module "ecs_main" {
  source  = "terraform-aws-modules/ecs/aws"
  version = "5.12.1" # Verifique se a sua versão do módulo suporta service_connect_configuration

  cluster_name          = local.ecs_cluster_config.cluster_name
  cluster_configuration = local.ecs_cluster_config.cluster_configuration
  fargate_capacity_providers = local.ecs_cluster_config.fargate_capacity_providers

  services = { for service_name, service_attrs in local.ecs_service_configs : service_name => {
      name                       = service_name
      desired_count              = service_attrs.desired_count
      launch_type                = service_attrs.launch_type
      fargate_platform_version   = service_attrs.fargate_platform_version
      cpu                        = service_attrs.cpu
      memory                     = service_attrs.memory
      container_definitions      = service_attrs.container_definitions
      load_balancer              = service_attrs.load_balancer
      subnet_ids                 = service_attrs.subnet_ids
      security_group_rules       = service_attrs.security_group_rules

      deployment_controller      = service_attrs.deployment_controller
      deployment_minimum_healthy_percent = service_attrs.deployment_minimum_healthy_percent
      deployment_maximum_percent = service_attrs.deployment_maximum_percent

      tags                       = service_attrs.tags

      tasks_iam_role_name        = service_attrs.tasks_iam_role_name
      tasks_iam_role_description = service_attrs.tasks_iam_role_description
      tasks_iam_role_policies    = service_attrs.tasks_iam_role_policies
      tasks_iam_role_statements  = service_attrs.tasks_iam_role_statements

      # === NOVO PARÂMETRO PARA O MÓDULO ===
      service_connect_configuration = service_attrs.service_connect_configuration
      # ====================================
    }
  }

  depends_on = [
    aws_lb_listener.dynamic_listener,
    aws_service_discovery_http_namespace.this # Adicionar dependência para o namespace
  ]

  tags = local.ecs_cluster_config.tags
}

# ... (restante do main.tf, inalterado)


{
  "project_name": "my-org-project",
  "aws_region": "us-east-1",
  // ...
  "service_discovery_namespace_name": "my-app-namespace", // Se você definiu essa nova variável
  "ecs_services": {
    "frontend-app": {
      "cpu": 1024,
      "memory": 2048,
      "container_definitions": {
        "app": {
          "image": "public.ecr.aws/ecs-sample-app:latest",
          "container_port": 80
        }
      },
      // ...
      "additional_task_role_policy_arns": [],
      "enable_service_connect": true,  // Habilita o Service Connect
      "service_connect_client_alias": "frontend" // Opcional: alias personalizado
    },
    "backend-api": {
      "cpu": 512,
      "memory": 1024,
      "container_definitions": {
        "api": {
          "image": "my-account-id.dkr.ecr.us-east-1.amazonaws.com/my-backend-api:v1.0",
          "container_port": 3000
        }
      },
      // ...
      "additional_task_role_policy_arns": [],
      "enable_service_connect": true,  // Habilita o Service Connect
      "service_connect_client_alias": "backend" // Opcional: alias personalizado
    }
  }
}


